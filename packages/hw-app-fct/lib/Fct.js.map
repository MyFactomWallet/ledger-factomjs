{"version":3,"sources":["../src/Fct.js"],"names":["Fct","transport","decorateAppAPIMethods","path","boolDisplay","boolChainCode","bipPath","BIPPath","fromString","toPathArray","buffer","Buffer","alloc","length","boolIdAddr","writeInt8","forEach","segment","index","writeUInt32BE","send","then","result","publicKeyLength","response","addressLength","rcd","slice","toString","publicKey","from","address","chainidstart","chaincode","chainid","rawTxHex","paths","offset","rawTx","toSend","maxChunkSize","chunkSize","element","copy","push","data","i","apduResponse","r","rcdType","v","readUInt16BE","s","signature","ischaincommit","p1","p2","k","rawMessage","tosha512","l","readUInt8","h","hash","chainIdHex","fattype","fattxbuffer","Error","arbitraryDataEnabled","version"],"mappings":"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","file":"Fct.js","sourcesContent":["/********************************************************************************\n *   Ledger Node JS API for Factom\n *   (c) 2018 The Factoid Authority \n *            ledger@factoid.org\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//@flow\n\nimport { splitPath, foreach } from \"./utils\";\nimport type Transport from \"@ledgerhq/hw-transport\";\nimport BIPPath from \"bip32-path\";\n\n/**\n * MyFactomWallet Ledger API\n *\n * @example\n * import Fct from \"@factoid.org/hw-app-fct\";\n * const fct = new Fct(transport)\n */\nexport default class Fct {\n  transport: Transport<*>;\n\n  constructor(transport: Transport<*>) {\n    this.transport = transport;\n    transport.decorateAppAPIMethods(\n      this,\n      [\"getAddress\", \"signTransaction\", \"signCommit\", \"signMessageRaw\", \"signMessageHash\", \"signFatTransaction\", \"storeChainId\", \"getAppConfiguration\"],\n      \"TFA\"\n    );\n  }\n\n  /**\n   * get Factom address for a given BIP 32 path.\n   * @param path a path in BIP 32 format (note: all paths muth be hardened (e.g. .../0'/0' )\n   * @option boolDisplay if true, optionally display the address on the device \n   * @return an object with a rct, publicKey, and address with optional chainCode and chainid\n   * @example\n   * const fctaddr = await fct.getAddress(\"44'/131'/0'/0/0\")\n   * const ecaddr = await fct.getAddress(\"44'/132'/0'/0/0\")\n   * const idaddr = await fct.getAddress(\"44'/281'/0'/0/0\")\n   */\n  \n  getAddress(\n    path: string,\n    boolDisplay?: boolean,\n    boolChainCode?: boolean\n  ): Promise<{\n    rcd: string,\n    publicKey: string,\n    address: string,\n    chaincode: string,\n    chainid : string\n  }> {\n    const bipPath = BIPPath.fromString(path).toPathArray();\n\n    let buffer = new Buffer.alloc(1 + bipPath.length * 4);\n    const boolIdAddr = (bipPath[1] === 0x80000119)\n    \n    buffer.writeInt8(bipPath.length, 0);\n    bipPath.forEach((segment, index) => {\n      buffer.writeUInt32BE(segment, 1 + index * 4);\n    });\n\n    return this.transport\n      .send(\n        0xe0,\n        0x02,\n        boolDisplay || false ? 0x01 : 0x00,\n        boolChainCode || false ? 0x01 : 0x00,\n        buffer\n      )\n      .then(response => {\n        let result = {};\n        let publicKeyLength = response[0];\n        let addressLength = response[1 + publicKeyLength];\n        result.rcd = response\n          .slice(1, 1 + publicKeyLength)\n          .toString(\"hex\")\n        result.publicKey = Buffer.from(result.rcd,'hex').slice(1)\n        result.address =\n          response\n            .slice(\n              1 + publicKeyLength + 1,\n              1 + publicKeyLength + 1 + addressLength\n            )\n            .toString(\"ascii\")\n        let chainidstart = 0\n        result.chaincode = \"\"\n        result.chainid = \"\"\n        \n        if ( boolChainCode || false ) {\n          result.chaincode = response\n            .slice(\n              1 + publicKeyLength + 1 + addressLength,\n              1 + publicKeyLength + 1 + addressLength + 32\n            ).toString(\"hex\")\n          chainidstart = 32\n        } \n        \n        if (boolIdAddr) {\n           result.chainid = response.\n             slice( 1 + publicKeyLength + 1 + addressLength + chainidstart,\n                    1 + publicKeyLength + 1 + addressLength + chainidstart + 32 ).\n             toString(\"hex\")\n        }\n        \n        return result\n      });\n  }\n\n  /**\n   * You can sign a transaction and retrieve v, r, s given the raw transaction and the BIP 32 path of the account to sign\n   * @param path a path in BIP 32 format (note: all paths muth be hardened (e.g. .../0'/0' )\n   * @param rawTxHex The raw fct transaction request\n   * @example\n   const result = await fct.signTransaction(\"44'/131'/0'/0/0\", \"02016253dfaa7301010087db406ff65cb9dd72a1e99bcd51da5e03b0ccafc237dbf1318a8d7438e22371c892d6868d20f02894db071e2eb38fdc56c697caaeba7dc19bddae2c6e7084cc3120d667b49f\")\n   */\n  signTransaction(\n    path: string,\n    rawTxHex: string /*change to tx: Transation */\n  ): Promise<{\n    v: string,\n    r: string,\n    s: string\n  }> {\n    let paths = splitPath(path);\n    let offset = 0;\n    let rawTx = new Buffer(rawTxHex, \"hex\");\n    let toSend = [];\n    let response;\n    while (offset !== rawTx.length) {\n      let maxChunkSize = offset === 0 ? 150 - 1 - paths.length * 4 : 150 \n      let chunkSize =\n        offset + maxChunkSize > rawTx.length\n          ? rawTx.length - offset\n          : maxChunkSize;\n      let buffer = new Buffer(\n        offset === 0 ? 1 + paths.length * 4 + chunkSize : chunkSize\n      );\n      if (offset === 0) {\n        buffer[0] = paths.length;\n        paths.forEach((element, index) => {\n          buffer.writeUInt32BE(element, 1 + 4 * index);\n        });\n        rawTx.copy(buffer, 1 + 4 * paths.length, offset, offset + chunkSize);\n      } else {\n        rawTx.copy(buffer, 0, offset, offset + chunkSize)\n      }\n      toSend.push(buffer)\n      offset += chunkSize\n    }\n    return foreach(toSend, (data, i) =>\n      this.transport\n        .send(0xe0, 0x04, i === 0 ? 0x00 : 0x80, i === toSend.length-1 ? 0x01 : 0x00, data)\n        .then(apduResponse => {\n          response = apduResponse;\n        })\n    ).then(() => {\n      \n      const r = response.slice(0, 33).toString('hex')\n      const rcdType = response.slice(0, 1).toString('hex')\n      const publicKey = response.slice(1, 33).toString('hex')\n\n      //length of signature should be 64\n      const v = response.slice(33, 33 + 2).readUInt16BE(0)\n      //signature\n      const s = response.slice(35, 35 + v ).toString('hex')\n      let signature = s\n      return { v, r, s, rcdType, publicKey, signature }\n    });\n  }\n\n  /**\n   * You can sign an entry or chain commit and retrieve publicKey(k) and signature(s) given the raw transaction and the BIP 32 path of the account to sign\n   * @param path a path in BIP 32 format (note: all paths muth be hardened (e.g. .../0'/0' )\n   * @param rawTxHex this is the ledger for a entry or chain commit\n   * @param ischaincommit set this to true if the rawTxHex is a chain commit ledger.\n   * @example\n   fct.signCommit(\"44'/132'/0'/0/0\", \"00016227acddfe57cf6740c4f30ae39d71f75710fb4ea9c843d5c01755329a42ccab52034e1f7901d5b8efdb52a15c4007d341eb1193903a021ed7aaa9a3cf4234c32ef8a213de00\",false).then(result => ...)\n   */\n  signCommit(\n    path: string,\n    rawTxHex: string, \n    ischaincommit?: boolean\n  ): Promise<{\n    k: string,\n    s: string\n  }> {\n    const bipPath = BIPPath.fromString(path).toPathArray();\n    let offset = 0\n    let p1 = 0\n    let p2 = ischaincommit || 0\n    let rawTx = new Buffer(rawTxHex, \"hex\")\n    let toSend = []\n    let response\n    while (offset !== rawTx.length) {\n      let maxChunkSize = offset === 0 ? 150 - 1 - bipPath.length * 4 : 150;\n      let chunkSize =\n        offset + maxChunkSize > rawTx.length\n          ? rawTx.length - offset\n          : maxChunkSize\n      let buffer = new Buffer(\n        offset === 0 ? 1 + bipPath.length * 4 + chunkSize : chunkSize\n      )\n      if (offset === 0) {\n        buffer.writeInt8(bipPath.length, 0);\n        bipPath.forEach((segment, index) => {\n          buffer.writeUInt32BE(segment, 1 + index * 4);\n        });\n\n        rawTx.copy(buffer, 1 + 4 * bipPath.length, offset, offset + chunkSize)\n      } else {\n        rawTx.copy(buffer, 0, offset, offset + chunkSize)\n      }\n      toSend.push(buffer)\n      offset += chunkSize\n    }\n    return foreach(toSend, (data, i) =>\n      this.transport\n        .send(0xe0, 0x12, i === 0 ? 0x00 : 0x80, (i === toSend.length-1 ? 0x02 : 0x00) | (p2 ? 0x01 : 0x00) , data)\n        .then(apduResponse => {\n          response = apduResponse;\n        })\n    ).then(() => {\n      \n      const k = response.slice(0, 32).toString('hex')\n      //length of signature should be 64\n      const v = response.slice(32, 32 + 2).readUInt16BE(0)\n      //signature\n      const s = response.slice(34, 34 + v ).toString('hex')\n      let publicKey = k\n      let signature = s\n      return { k, s, publicKey, signature }\n    })\n  }\n\n /**\n   * You can sign an arbitrary message and retrieve v, k, s given the raw transaction and the BIP 32 path of the account to sign\n   * The message will be automatically hashed by the device using either sha256 (default) or sha512 if tosha512 is set to true.\n   * If coin types 131 or 132 are used \"FCT Signed Message\\n\" or \"EC Signed Message\\n\" is prepended to the message inside the ledger\n   * prior to the device hashing then signing the hash.  If the identity coin type 281 is used, then the message is directly hashed\n   * then signed by the ledger.\n   * @param path a path in BIP 32 format (note: all paths muth be hardened (e.g. .../0'/0' )\n   * @param rawMessage this is the raw data Buffer to be signed\n   * @param tosha512 set this to true to hash the rawMessage using sha512, the default (or false) is sha256.\n   * @example\n   fct.signMessageHash(\"44'/281'/0'/0/0\", \"The quick brown fox jumps over the lazy dog.\",true).then(result => ...)\n   */\n  signMessageHash(\n    path: string,\n    rawMessage: Buffer, \n    tosha512?: boolean\n  ): Promise<{\n    k: string,\n    s: string,\n    h: string\n  }> {\n    const bipPath = BIPPath.fromString(path).toPathArray();\n    let offset = 0\n    let p1 = 0\n    let p2 = tosha512 || 0\n    let rawTx = rawMessage\n    let toSend = []\n    let response\n\n    while (offset !== rawTx.length) {\n      let maxChunkSize = offset === 0 ? 150 - 1 - bipPath.length * 4 : 150;\n      let chunkSize =\n        offset + maxChunkSize > rawTx.length\n          ? rawTx.length - offset\n          : maxChunkSize\n      let buffer = new Buffer(\n        offset === 0 ? 1 + bipPath.length * 4 + chunkSize : chunkSize\n      )\n      if (offset === 0) {\n        buffer.writeInt8(bipPath.length, 0);\n        bipPath.forEach((segment, index) => {\n          buffer.writeUInt32BE(segment, 1 + index * 4);\n        });\n        rawTx.copy(buffer, 1 + 4 * bipPath.length, offset, offset + chunkSize)\n      } else {\n        rawTx.copy(buffer, 0, offset, offset + chunkSize)\n      }\n      toSend.push(buffer)\n      offset += chunkSize\n    }\n    return foreach(toSend, (data, i) =>\n      this.transport\n        .send(0xe0, 0x14, i === 0 ? 0x00 : 0x80, (i === toSend.length-1 ? 0x02 : 0x00) | (p2 ? 0x01 : 0x00) , data)\n        .then(apduResponse => {\n          response = apduResponse;\n        })\n    ).then(() => {\n      \n      const k = response.slice(0, 32).toString('hex')\n      //length of signature should be 64\n      const v = response.slice(32, 32 + 2).readUInt16BE(0)\n      //signature\n      const s = response.slice(34, 34 + v ).toString('hex')\n      const l = response.slice(34 + v, 34 + v + 2).readUInt8(0);\n      //hash\n      const h = response.slice(36 + v, 36 + v + l).toString('hex')\n\n      let publicKey = k\n      let signature = s\n      let hash = h\n      return { k, s, h, publicKey, signature, hash }\n    })\n  }\n\n  /**\n   * You can sign an entry or chain commit and retrieve v, k, s given the raw transaction and the BIP 32 path of the account to sign\n   * @param path a path in BIP 32 format (note: all paths muth be hardened (e.g. .../0'/0' )\n   * @param rawTxHex this is the ledger for a entry or chain commit\n   * @param ischaincommit set this to true if the rawTxHex is a chain commit ledger.\n   * @example\n   fct.storeChainId(\"44'/132'/0'/0'/0\", \"00016227acddfe57cf6740c4f30ae39d71f75710fb4ea9c843d5c01755329a42ccab52034e1f7901d5b8efdb52a15c4007d341eb1193903a021ed7aaa9a3cf4234c32ef8a213de00\",false).then(result => ...)\n   */\n\n  storeChainId(\n    chainIdHex: string\n  ): Promise<{\n  }> {\n    let p1 = 0\n    let p2 = 0\n    let rawTx = new Buffer(chainIdHex, \"hex\")\n    let toSend = []\n    let response\n\n    toSend.push(rawTx)\n      \n    return foreach(toSend, (data, i) =>\n      this.transport\n        .send(0xe0, 0x18, p1, p2 , data)\n        .then(apduResponse => {\n          response = apduResponse;\n        })\n    ).then(() => {\n      return { }\n    })\n  }\n\n    /**\n   * This function will sign a raw message using the identity coin type only.  Attempts to sign with FCT or EC addresses will\n   * be rejected by the device.\n   * @param path a path in BIP 32 format \n   * @param rawMessage this is the raw data Buffer to be signed\n   * @example\n   fct.signMessageRaw(\"44'/281'/0'/0/0\", \"The quick brown fox jumps over the lazy dog.\").then(result => ...)\n   */\n  signMessageRaw(\n    path: string,\n    rawMessage: Buffer\n  ): Promise<{\n    s: string,\n    v: string,\n    r: string\n  }> {\n    const bipPath = BIPPath.fromString(path).toPathArray();\n    let offset = 0\n    let p1 = 0\n    let p2 = 0\n    let rawTx = rawMessage\n    let toSend = []\n    let response\n    while (offset !== rawTx.length) {\n      let maxChunkSize = offset === 0 ? 150 - 1 - bipPath.length * 4 : 150;\n      let chunkSize =\n        offset + maxChunkSize > rawTx.length\n          ? rawTx.length - offset\n          : maxChunkSize\n      let buffer = new Buffer(\n        offset === 0 ? 1 + bipPath.length * 4 + chunkSize : chunkSize\n      )\n      if (offset === 0) {\n        buffer.writeInt8(bipPath.length, 0);\n        bipPath.forEach((segment, index) => {\n          buffer.writeUInt32BE(segment, 1 + index * 4);\n        });\n        rawTx.copy(buffer, 1 + 4 * bipPath.length, offset, offset + chunkSize)\n      } else {\n        rawTx.copy(buffer, 0, offset, offset + chunkSize)\n      }\n      toSend.push(buffer)\n      offset += chunkSize\n    }\n    return foreach(toSend, (data, i) =>\n      this.transport\n        .send(0xe0, 0x16, i === 0 ? 0x00 : 0x80, (i === toSend.length-1 ? 0x01 : 0x00), data)\n        .then(apduResponse => {\n          response = apduResponse;\n        })\n    ).then(() => {\n      \n      const k = response.slice(0, 32).toString('hex')\n      //length of signature should be 64\n      const v = response.slice(32, 32 + 2).readUInt16BE(0)\n      //signature\n      const s = response.slice(34, 34 + v ).toString('hex')\n      //const l = response.slice(34 + v, 34 + v + 2).readUInt8(0);\n      //const h = response.slice(36 + v, 36 + v + l).toString('hex') \n      let publicKey = k\n      let signature = s\n      return { v, k, s, publicKey, signature }\n    })\n  }\n\n      \n    /**\n   * This function will sign a FAT 0 or 1 transaction using the Factoid Address.  \n   * @param path a path in BIP 32 format \n   * @param fattype FAT protocol transaction type index 0: FAT-0, 1: FAT-1\n   * @param fattxraw this is the raw data fat transaction to be hashed then signed by device, Buffer.concat([index, timestamp, chainId, content])\n   * @example\n   fct.signFatTransaction(\"44'/131'/0'/0/0\", \"The quick brown fox jumps over the lazy dog.\").then(result => ...)\n   */\n  signFatTransaction(\n    path: string,\n    fattype: number,\n    fattxbuffer : Buffer\n  ): Promise<{\n    s: string,\n    v: string,\n    r: string\n  }> {\n    const bipPath = BIPPath.fromString(path).toPathArray();\n    let offset = 0\n    let p1 = 0\n    let p2 = fattype\n    if ( p2 > 255 || p2 < 0 ) {\n        throw new Error(\"Invalid Transaction Type: FAT Transaction Type must be < 256 and >= 0\")\n    }\n    let rawTx = fattxbuffer\n    let toSend = []\n    let response\n    while (offset !== rawTx.length) {\n      let maxChunkSize = offset === 0 ? 150 - 1 - bipPath.length * 4 : 150;\n      let chunkSize =\n        offset + maxChunkSize > rawTx.length\n          ? rawTx.length - offset\n          : maxChunkSize\n      let buffer = new Buffer(\n        offset === 0 ? 1 + bipPath.length * 4 + chunkSize : chunkSize\n      )\n      if (offset === 0) {\n        buffer.writeInt8(bipPath.length, 0);\n        bipPath.forEach((segment, index) => {\n          buffer.writeUInt32BE(segment, 1 + index * 4);\n        });\n        rawTx.copy(buffer, 1 + 4 * bipPath.length, offset, offset + chunkSize)\n      } else {\n        rawTx.copy(buffer, 0, offset, offset + chunkSize)\n      }\n      toSend.push(buffer)\n      offset += chunkSize\n    }\n    return foreach(toSend, (data, i) =>\n      this.transport\n        .send(0xe0, 0x20, i === 0 ? 0x00 : (i === toSend.length-1 ? 0x81 : 0x80), p2, data)\n        .then(apduResponse => {\n          response = apduResponse;\n        })\n    ).then(() => {\n      \n      //const k = response.slice(0, 32).toString('hex')\n      //length of signature should be 64\n      //const v = response.slice(32, 32 + 2).readUInt16BE(0)\n      //signature\n      //const s = response.slice(34, 34 + v ).toString('hex')\n      //const l = response.slice(34 + v, 34 + v + 2).readUInt8(0);\n      //hash\n\n      \n      const rcdType = response.slice(0, 1).toString('hex')\n      const publicKey = response.slice(1, 33).toString('hex')\n      //length of signature should be 64\n      const v = response.slice(33, 33 + 2).readUInt16BE(0)\n      //signature\n      const signature = response.slice(35, 35 + v ).toString('hex')\n      \n      //hash\n      //const l = response.slice(34 + v, 34 + v + 2).readUInt8(0);\n      //const l = response.slice(36, 36 + v).readUInt16BE(0)\n      const hash = response.slice(35 + v, 35 + v + 64 ).toString('hex')\n      return { rcdType, publicKey, signature, hash }\n      \n      \n      //return { k, s, h }\n    })\n  }\n  \n  /**\n   */\n  getAppConfiguration(): Promise<{\n    arbitraryDataEnabled: number,\n    version: string\n  }> {\n    return this.transport.send(0xe0, 0x06, 0x00, 0x00).then(response => {\n      let result = {};\n      result.arbitraryDataEnabled = response[0] & 0x01;\n      result.version = \"\" + response[1] + \".\" + response[2] + \".\" + response[3];\n      return result;\n    })\n  }\n}\n"]}