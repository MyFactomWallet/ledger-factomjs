{"version":3,"sources":["../src/Fct.js"],"names":["Fct","transport","decorateAppAPIMethods","path","boolDisplay","paths","buffer","Buffer","alloc","length","forEach","element","index","writeUInt32BE","send","then","result","publicKeyLength","response","addressLength","publicKey","slice","toString","address","rawTxHex","offset","rawTx","toSend","maxChunkSize","chunkSize","copy","push","data","i","apduResponse","r","v","readUInt16BE","s","ischaincommit","p1","p2","k","arbitraryDataEnabled","version"],"mappings":"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","file":"Fct.js","sourcesContent":["/********************************************************************************\n *   Ledger Node JS API for Factom\n *   (c) 2018 The Factoid Authority \n *            ledger@factoid.org\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//@flow\n\nimport { splitPath, foreach } from \"./utils\";\nimport type Transport from \"@ledgerhq/hw-transport\";\n\n/**\n * MyFactomWallet Ledger API\n *\n * @example\n * import Fct from \"@factoid.org/hw-app-fct\";\n * const fct = new Fct(transport)\n */\nexport default class Fct {\n  transport: Transport<*>;\n\n  constructor(transport: Transport<*>) {\n    this.transport = transport;\n    transport.decorateAppAPIMethods(\n      this,\n      [\"getAddress\", \"signTransaction\", \"signCommit\", \"getAppConfiguration\"],\n      \"TFA\"\n    );\n  }\n\n  /**\n   * get Factom address for a given BIP 32 path.\n   * @param path a path in BIP 32 format (note: all paths muth be hardened (e.g. .../0'/0' )\n   * @option boolDisplay if true, optionally display the address on the device \n   * @return an object with a publicKey and address \n   * @example\n   * const fctaddr = await fct.getAddress(\"44'/131'/0'/0'/0'\")\n   * const ecaddr = await fct.getAddress(\"44'/132'/0'/0'/0'\")\n   * const idaddr = await fct.getAddress(\"44'/143165576'/0'/0'/0'\")\n   */\n  getAddress(\n    path: string,\n    boolDisplay?: boolean\n  ): Promise<{\n    publicKey: string,\n    address: string\n  }> {\n    let paths = splitPath(path);\n    let buffer = new Buffer.alloc(1 + paths.length * 4);\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    return this.transport\n      .send(\n        0xe0,\n        0x02,\n        boolDisplay || false ? 0x01 : 0x00,\n        0x00,\n        buffer\n      )\n      .then(response => {\n        let result = {};\n        let publicKeyLength = response[0];\n        let addressLength = response[1 + publicKeyLength];\n        result.publicKey = response\n          .slice(1, 1 + publicKeyLength)\n          .toString(\"hex\")\n        result.address =\n          response\n            .slice(\n              1 + publicKeyLength + 1,\n              1 + publicKeyLength + 1 + addressLength\n            )\n            .toString(\"ascii\")\n        return result\n      });\n  }\n\n  /**\n   * You can sign a transaction and retrieve v, r, s given the raw transaction and the BIP 32 path of the account to sign\n   * @param path a path in BIP 32 format (note: all paths muth be hardened (e.g. .../0'/0' )\n   * @param rawTxHex The raw fct transaction request\n   * @example\n   const result = await fct.signTransaction(\"44'/131'/0'/0'/0'\", \"02016253dfaa7301010087db406ff65cb9dd72a1e99bcd51da5e03b0ccafc237dbf1318a8d7438e22371c892d6868d20f02894db071e2eb38fdc56c697caaeba7dc19bddae2c6e7084cc3120d667b49f\")\n   */\n  signTransaction(\n    path: string,\n    rawTxHex: string /*change to tx: Transation */\n  ): Promise<{\n    s: string,\n    v: string,\n    r: string\n  }> {\n    let paths = splitPath(path);\n    let offset = 0;\n    let rawTx = new Buffer(rawTxHex, \"hex\");\n    let toSend = [];\n    let response;\n    while (offset !== rawTx.length) {\n      let maxChunkSize = offset === 0 ? 150 - 1 - paths.length * 4 : 150 \n      let chunkSize =\n        offset + maxChunkSize > rawTx.length\n          ? rawTx.length - offset\n          : maxChunkSize;\n      let buffer = new Buffer(\n        offset === 0 ? 1 + paths.length * 4 + chunkSize : chunkSize\n      );\n      if (offset === 0) {\n        buffer[0] = paths.length;\n        paths.forEach((element, index) => {\n          buffer.writeUInt32BE(element, 1 + 4 * index);\n        });\n        rawTx.copy(buffer, 1 + 4 * paths.length, offset, offset + chunkSize);\n      } else {\n        rawTx.copy(buffer, 0, offset, offset + chunkSize);\n      }\n      toSend.push(buffer);\n      offset += chunkSize;\n    }\n    return foreach(toSend, (data, i) =>\n      this.transport\n        .send(0xe0, 0x04, i === 0 ? 0x00 : 0x80, i === toSend.length-1 ? 0x01 : 0x00, data)\n        .then(apduResponse => {\n          response = apduResponse;\n        })\n    ).then(() => {\n      \n      const r = response.slice(0, 33).toString('hex')\n      //length of signature should be 64\n      const v = response.slice(33, 33 + 2).readUInt16BE(0)\n      //signature\n      const s = response.slice(35, 35 + v ).toString('hex')\n      return { v, r, s }\n    });\n  }\n\n  /**\n   * You can sign an entry or chain commit and retrieve v, k, s given the raw transaction and the BIP 32 path of the account to sign\n   * @param path a path in BIP 32 format (note: all paths muth be hardened (e.g. .../0'/0' )\n   * @param rawTxHex this is the ledger for a entry or chain commit\n   * @param ischaincommit set this to true if the rawTxHex is a chain commit ledger.\n   * @example\n   fct.signCommit(\"44'/132'/0'/0'/0\", \"00016227acddfe57cf6740c4f30ae39d71f75710fb4ea9c843d5c01755329a42ccab52034e1f7901d5b8efdb52a15c4007d341eb1193903a021ed7aaa9a3cf4234c32ef8a213de00\",false).then(result => ...)\n   */\n  signCommit(\n    path: string,\n    rawTxHex: string, /*change to tx: Transation */\n    ischaincommit?: boolean\n  ): Promise<{\n    s: string,\n    v: string,\n    r: string\n  }> {\n    let paths = splitPath(path)\n    let offset = 0\n    let p1 = 0\n    let p2 = ischaincommit || 0\n    let rawTx = new Buffer(rawTxHex, \"hex\")\n    let toSend = []\n    let response\n    while (offset !== rawTx.length) {\n      let maxChunkSize = offset === 0 ? 150 - 1 - paths.length * 4 : 150;\n      let chunkSize =\n        offset + maxChunkSize > rawTx.length\n          ? rawTx.length - offset\n          : maxChunkSize\n      let buffer = new Buffer(\n        offset === 0 ? 1 + paths.length * 4 + chunkSize : chunkSize\n      )\n      if (offset === 0) {\n        buffer[0] = paths.length\n        paths.forEach((element, index) => {\n          buffer.writeUInt32BE(element, 1 + 4 * index)\n        })\n        rawTx.copy(buffer, 1 + 4 * paths.length, offset, offset + chunkSize)\n      } else {\n        rawTx.copy(buffer, 0, offset, offset + chunkSize)\n      }\n      toSend.push(buffer)\n      offset += chunkSize\n    }\n    return foreach(toSend, (data, i) =>\n      this.transport\n        .send(0xe0, 0x12, i === 0 ? 0x00 : 0x80, (i === toSend.length-1 ? 0x02 : 0x00) | (p2 ? 0x01 : 0x00) , data)\n        .then(apduResponse => {\n          response = apduResponse;\n        })\n    ).then(() => {\n      \n      const k = response.slice(0, 32).toString('hex')\n      //length of signature should be 64\n      const v = response.slice(32, 32 + 2).readUInt16BE(0)\n      //signature\n      const s = response.slice(34, 34 + v ).toString('hex')\n      return { v, k, s }\n    })\n  }\n\n  /**\n   */\n  getAppConfiguration(): Promise<{\n    arbitraryDataEnabled: number,\n    version: string\n  }> {\n    return this.transport.send(0xe0, 0x06, 0x00, 0x00).then(response => {\n      let result = {};\n      result.arbitraryDataEnabled = response[0] & 0x01;\n      result.version = \"\" + response[1] + \".\" + response[2] + \".\" + response[3];\n      return result;\n    })\n  }\n}\n"]}